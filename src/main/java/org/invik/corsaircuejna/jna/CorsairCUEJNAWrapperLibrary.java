package org.invik.corsaircuejna.jna;

import org.bridj.*;
import org.bridj.ann.Library;
import org.bridj.ann.Name;
import org.bridj.ann.Ptr;
import org.bridj.ann.Runtime;

import java.util.*;

/**
 * Wrapper for library <b>CorsairCUEJNAWrapper</b><br>
 * This file was autogenerated by <a href="http://jnaerator.googlecode.com/">JNAerator</a>,<br>
 * a tool written by <a href="http://ochafik.com/">Olivier Chafik</a> that <a href="http://code.google.com/p/jnaerator/wiki/CreditsAndLicense">uses a few opensource projects.</a>.<br>
 * For help, please visit <a href="http://nativelibs4java.googlecode.com/">NativeLibs4Java</a> or <a href="http://bridj.googlecode.com/">BridJ</a> .
 */
@Library("CorsairCUEJNAWrapper.x64_2013")
@Runtime(CRuntime.class) 
public class CorsairCUEJNAWrapperLibrary {
	static {
		BridJ.register();
	}
	/**
	 * enum values<br>
	 * <i>native declaration : include\CorsairLedIdEnum.h:3</i>
	 */
	public enum CorsairLedId implements IntValuedEnum<CorsairLedId > {
		CLI_Invalid(0),
		CLK_Escape(1),
		CLK_F1(2),
		CLK_F2(3),
		CLK_F3(4),
		CLK_F4(5),
		CLK_F5(6),
		CLK_F6(7),
		CLK_F7(8),
		CLK_F8(9),
		CLK_F9(10),
		CLK_F10(11),
		CLK_F11(12),
		CLK_GraveAccentAndTilde(13),
		CLK_1(14),
		CLK_2(15),
		CLK_3(16),
		CLK_4(17),
		CLK_5(18),
		CLK_6(19),
		CLK_7(20),
		CLK_8(21),
		CLK_9(22),
		CLK_0(23),
		CLK_MinusAndUnderscore(24),
		CLK_Tab(25),
		CLK_Q(26),
		CLK_W(27),
		CLK_E(28),
		CLK_R(29),
		CLK_T(30),
		CLK_Y(31),
		CLK_U(32),
		CLK_I(33),
		CLK_O(34),
		CLK_P(35),
		CLK_BracketLeft(36),
		CLK_CapsLock(37),
		CLK_A(38),
		CLK_S(39),
		CLK_D(40),
		CLK_F(41),
		CLK_G(42),
		CLK_H(43),
		CLK_J(44),
		CLK_K(45),
		CLK_L(46),
		CLK_SemicolonAndColon(47),
		CLK_ApostropheAndDoubleQuote(48),
		CLK_LeftShift(49),
		CLK_NonUsBackslash(50),
		CLK_Z(51),
		CLK_X(52),
		CLK_C(53),
		CLK_V(54),
		CLK_B(55),
		CLK_N(56),
		CLK_M(57),
		CLK_CommaAndLessThan(58),
		CLK_PeriodAndBiggerThan(59),
		CLK_SlashAndQuestionMark(60),
		CLK_LeftCtrl(61),
		CLK_LeftGui(62),
		CLK_LeftAlt(63),
		CLK_Lang2(64),
		CLK_Space(65),
		CLK_Lang1(66),
		CLK_International2(67),
		CLK_RightAlt(68),
		CLK_RightGui(69),
		CLK_Application(70),
		CLK_LedProgramming(71),
		CLK_Brightness(72),
		CLK_F12(73),
		CLK_PrintScreen(74),
		CLK_ScrollLock(75),
		CLK_PauseBreak(76),
		CLK_Insert(77),
		CLK_Home(78),
		CLK_PageUp(79),
		CLK_BracketRight(80),
		CLK_Backslash(81),
		CLK_NonUsTilde(82),
		CLK_Enter(83),
		CLK_International1(84),
		CLK_EqualsAndPlus(85),
		CLK_International3(86),
		CLK_Backspace(87),
		CLK_Delete(88),
		CLK_End(89),
		CLK_PageDown(90),
		CLK_RightShift(91),
		CLK_RightCtrl(92),
		CLK_UpArrow(93),
		CLK_LeftArrow(94),
		CLK_DownArrow(95),
		CLK_RightArrow(96),
		CLK_WinLock(97),
		CLK_Mute(98),
		CLK_Stop(99),
		CLK_ScanPreviousTrack(100),
		CLK_PlayPause(101),
		CLK_ScanNextTrack(102),
		CLK_NumLock(103),
		CLK_KeypadSlash(104),
		CLK_KeypadAsterisk(105),
		CLK_KeypadMinus(106),
		CLK_KeypadPlus(107),
		CLK_KeypadEnter(108),
		CLK_Keypad7(109),
		CLK_Keypad8(110),
		CLK_Keypad9(111),
		CLK_KeypadComma(112),
		CLK_Keypad4(113),
		CLK_Keypad5(114),
		CLK_Keypad6(115),
		CLK_Keypad1(116),
		CLK_Keypad2(117),
		CLK_Keypad3(118),
		CLK_Keypad0(119),
		CLK_KeypadPeriodAndDelete(120),
		CLK_G1(121),
		CLK_G2(122),
		CLK_G3(123),
		CLK_G4(124),
		CLK_G5(125),
		CLK_G6(126),
		CLK_G7(127),
		CLK_G8(128),
		CLK_G9(129),
		CLK_G10(130),
		CLK_VolumeUp(131),
		CLK_VolumeDown(132),
		CLK_MR(133),
		CLK_M1(134),
		CLK_M2(135),
		CLK_M3(136),
		CLK_G11(137),
		CLK_G12(138),
		CLK_G13(139),
		CLK_G14(140),
		CLK_G15(141),
		CLK_G16(142),
		CLK_G17(143),
		CLK_G18(144),
		CLK_International5(145),
		CLK_International4(146),
		CLK_Fn(147),
		CLM_1(148),
		CLM_2(149),
		CLM_3(150),
		CLM_4(151),
		CLH_LeftLogo(152),
		CLH_RightLogo(153),
		CLK_Logo(154),
		CLMM_Zone1(155),
		CLMM_Zone2(156),
		CLMM_Zone3(157),
		CLMM_Zone4(158),
		CLMM_Zone5(159),
		CLMM_Zone6(160),
		CLMM_Zone7(161),
		CLMM_Zone8(162),
		CLMM_Zone9(163),
		CLMM_Zone10(164),
		CLMM_Zone11(165),
		CLMM_Zone12(166),
		CLMM_Zone13(167),
		CLMM_Zone14(168),
		CLMM_Zone15(169),
		CLI_Last(169);
		CorsairLedId(long value) {
			this.value = value;
		}
		public final long value;
		public long value() {
			return this.value;
		}
		public Iterator<CorsairLedId > iterator() {
			return Collections.singleton(this).iterator();
		}
		public static IntValuedEnum<CorsairLedId > fromValue(int value) {
			return FlagSet.fromValue(value, values());
		}
        public static CorsairLedId getByValue(long value) {
            final List<CorsairLedId> corsairLedIds = new ArrayList<>();
            Collections.addAll(corsairLedIds, values());
            Optional<CorsairLedId> corsairLogicalLayout = corsairLedIds.stream().filter(layout -> layout.value() == value).findFirst();
            if (corsairLogicalLayout.isPresent()) {
                return corsairLogicalLayout.get();
            }
            throw new IllegalArgumentException("Unknown value : " + value);
        }
	};
	/**
	 * contains list of available device types<br>
	 * enum values<br>
	 * <i>native declaration : include\CUESDK.h:3</i>
	 */
	public enum CorsairDeviceType implements IntValuedEnum<CorsairDeviceType > {
		CDT_Unknown(0),
		CDT_Mouse(1),
		CDT_Keyboard(2),
		CDT_Headset(3),
		CDT_MouseMat(4);
		CorsairDeviceType(long value) {
			this.value = value;
		}
		public final long value;
		public long value() {
			return this.value;
		}
		public Iterator<CorsairDeviceType > iterator() {
			return Collections.singleton(this).iterator();
		}
		public static IntValuedEnum<CorsairDeviceType > fromValue(int value) {
			return FlagSet.fromValue(value, values());
		}
		public static CorsairDeviceType getByValue(long value) {
			final List<CorsairDeviceType> corsairDeviceTypes = new ArrayList<>();
			Collections.addAll(corsairDeviceTypes, values());
			Optional<CorsairDeviceType> corsairDeviceType = corsairDeviceTypes.stream().filter(layout -> layout.value() == value).findFirst();
			if (corsairDeviceType.isPresent()) {
				return corsairDeviceType.get();
			}
			throw new IllegalArgumentException("Unknown value : " + value);
		}
	};
	/**
	 * contains list of available physical layouts for keyboards<br>
	 * enum values<br>
	 * <i>native declaration : include\CUESDK.h:12</i>
	 */
	public enum CorsairPhysicalLayout implements IntValuedEnum<CorsairPhysicalLayout > {
		/** dummy value */
		CPL_Invalid(0),
		CPL_US(1),
		CPL_UK(2),
		CPL_BR(3),
		CPL_JP(4),
		/** valid values for keyboard */
		CPL_KR(5),
		CPL_Zones1(6),
		CPL_Zones2(7),
		CPL_Zones3(8),
		/** valid values for mouse */
		CPL_Zones4(9);
		CorsairPhysicalLayout(long value) {
			this.value = value;
		}
		public final long value;
		public long value() {
			return this.value;
		}
		public Iterator<CorsairPhysicalLayout > iterator() {
			return Collections.singleton(this).iterator();
		}
		public static IntValuedEnum<CorsairPhysicalLayout > fromValue(int value) {
			return FlagSet.fromValue(value, values());
		}
		public static CorsairPhysicalLayout getByValue(long value) {
			final List<CorsairPhysicalLayout> corsairPhysicalLayouts = new ArrayList<>();
			Collections.addAll(corsairPhysicalLayouts, values());
			Optional<CorsairPhysicalLayout> corsairDeviceType = corsairPhysicalLayouts.stream().filter(layout -> layout.value() == value).findFirst();
			if (corsairDeviceType.isPresent()) {
				return corsairDeviceType.get();
			}
			throw new IllegalArgumentException("Unknown value : " + value);
		}
	};
	/**
	 * contains list of available logical layouts for keyboards<br>
	 * enum values<br>
	 * <i>native declaration : include\CUESDK.h:28</i>
	 */
	public enum CorsairLogicalLayout implements IntValuedEnum<CorsairLogicalLayout > {
		/** dummy value */
		CLL_Invalid(0),
		CLL_US_Int(1),
		CLL_NA(2),
		CLL_EU(3),
		CLL_UK(4),
		CLL_BE(5),
		CLL_BR(6),
		CLL_CH(7),
		CLL_CN(8),
		CLL_DE(9),
		CLL_ES(10),
		CLL_FR(11),
		CLL_IT(12),
		CLL_ND(13),
		CLL_RU(14),
		CLL_JP(15),
		CLL_KR(16),
		CLL_TW(17),
		CLL_MEX(18);
		CorsairLogicalLayout(long value) {
			this.value = value;
		}
		public final long value;
		public long value() {
			return this.value;
		}
		public Iterator<CorsairLogicalLayout > iterator() {
			return Collections.singleton(this).iterator();
		}
		public static IntValuedEnum<CorsairLogicalLayout > fromValue(int value) {
			return FlagSet.fromValue(value, values());
		}
		public static CorsairLogicalLayout getByValue(long value) {
			final List<CorsairLogicalLayout> corsairLogicalLayoutList = new ArrayList<>();
			Collections.addAll(corsairLogicalLayoutList, values());
			Optional<CorsairLogicalLayout> corsairLogicalLayout = corsairLogicalLayoutList.stream().filter(layout -> layout.value() == value).findFirst();
			if (corsairLogicalLayout.isPresent()) {
				return corsairLogicalLayout.get();
			}
			throw new IllegalArgumentException("Unknown value : " + value);
		}
	};
	/**
	 * contains list of device capabilities<br>
	 * enum values<br>
	 * <i>native declaration : include\CUESDK.h:51</i>
	 */
	public enum CorsairDeviceCaps implements IntValuedEnum<CorsairDeviceCaps > {
		/** for devices that do not support any SDK functions */
		CDC_None(0),
		/** for devices that has controlled lighting */
		CDC_Lighting(1);
		CorsairDeviceCaps(long value) {
			this.value = value;
		}
		public final long value;
		public long value() {
			return this.value;
		}
		public Iterator<CorsairDeviceCaps > iterator() {
			return Collections.singleton(this).iterator();
		}
		public static IntValuedEnum<CorsairDeviceCaps > fromValue(int value) {
			return FlagSet.fromValue(value, values());
		}
        public static CorsairDeviceCaps getByValue(long value) {
            final List<CorsairDeviceCaps> corsairDeviceCapss = new ArrayList<>();
            Collections.addAll(corsairDeviceCapss, values());
            Optional<CorsairDeviceCaps> corsairDeviceCaps = corsairDeviceCapss.stream().filter(layout -> layout.value() == value).findFirst();
            if (corsairDeviceCaps.isPresent()) {
                return corsairDeviceCaps.get();
            }
            throw new IllegalArgumentException("Unknown value : " + value);
        }
	};
	/**
	 * contains list of available SDK access modes<br>
	 * enum values<br>
	 * <i>native declaration : include\CUESDK.h:57</i>
	 */
	public enum CorsairAccessMode implements IntValuedEnum<CorsairAccessMode > {
		CAM_ExclusiveLightingControl(0);
		CorsairAccessMode(long value) {
			this.value = value;
		}
		public final long value;
		public long value() {
			return this.value;
		}
		public Iterator<CorsairAccessMode > iterator() {
			return Collections.singleton(this).iterator();
		}
		public static IntValuedEnum<CorsairAccessMode > fromValue(int value) {
			return FlagSet.fromValue(value, values());
		}
        public static CorsairAccessMode getByValue(long value) {
            final List<CorsairAccessMode> corsairAccessModes = new ArrayList<>();
            Collections.addAll(corsairAccessModes, values());
            Optional<CorsairAccessMode> corsairAccessMode = corsairAccessModes.stream().filter(layout -> layout.value() == value).findFirst();
            if (corsairAccessMode.isPresent()) {
                return corsairAccessMode.get();
            }
            throw new IllegalArgumentException("Unknown value : " + value);
        }
	};
	/**
	 * contains shared list of all errors which could happen during calling of Corsair* functions<br>
	 * enum values<br>
	 * <i>native declaration : include\CUESDK.h:62</i>
	 */
	public enum CorsairError implements IntValuedEnum<CorsairError > {
		/** if previously called function completed successfully */
		CE_Success(0),
		/** CUE is not running or was shut down or third-party control is disabled in CUE settings(runtime error) */
		CE_ServerNotFound(1),
		/** if some other client has or took over exclusive control (runtime error) */
		CE_NoControl(2),
		/** if developer did not perform protocol handshake(developer error) */
		CE_ProtocolHandshakeMissing(3),
		/** if developer is calling the function that is not supported by the server(either because protocol has broken by server or client or because the function is new and server is too old. Check JNACorsairProtocolDetails for details) (developer error) */
		CE_IncompatibleProtocol(4),
		/** if developer supplied invalid arguments to the function(for specifics look at function descriptions). (developer error) */
		CE_InvalidArguments(5);
		CorsairError(long value) {
			this.value = value;
		}
		public final long value;
		public long value() {
			return this.value;
		}
		public Iterator<CorsairError > iterator() {
			return Collections.singleton(this).iterator();
		}
		public static IntValuedEnum<CorsairError > fromValue(int value) {
			return FlagSet.fromValue(value, values());
		}
        public static CorsairError getByValue(long value) {
            final List<CorsairError> corsairAccessModes = new ArrayList<>();
            Collections.addAll(corsairAccessModes, values());
            Optional<CorsairError> corsairError = corsairAccessModes.stream().filter(layout -> layout.value() == value).findFirst();
            if (corsairError.isPresent()) {
                return corsairError.get();
            }
            throw new IllegalArgumentException("Unknown value : " + value);
        }

	};
	/** <i>native declaration : include\CUESDK.h:119</i> */
	public static abstract class CorsairSetLedsColorsAsync_CallbackType_callback extends Callback<CorsairSetLedsColorsAsync_CallbackType_callback > {
		public void apply(Pointer<? > voidPtr1, boolean bool1, IntValuedEnum<CorsairCUEJNAWrapperLibrary.CorsairError > CorsairError1) {
			apply(Pointer.getPeer(voidPtr1), bool1, (int)CorsairError1.value());
		}
		public void apply(@Ptr long voidPtr1, boolean bool1, int CorsairError1) {
			apply(Pointer.pointerToAddress(voidPtr1), bool1, FlagSet.fromValue(CorsairError1, CorsairCUEJNAWrapperLibrary.CorsairError.class));
		}
	};
	/** <i>native declaration : include\CorsairCUEJNAWrapper.h:6</i> */
	public static abstract class JNACorsairSetLedsColorsAsync_CallbackType_callback extends Callback<JNACorsairSetLedsColorsAsync_CallbackType_callback > {
		public void apply(Pointer<? > voidPtr1, boolean bool1) {
			apply(Pointer.getPeer(voidPtr1), bool1);
		}
		public void apply(@Ptr long voidPtr1, boolean bool1) {
			apply(Pointer.pointerToAddress(voidPtr1), bool1);
		}
	};
	/**
	 * set specified leds to some colors.The color is retained until changed by successive calls.This function does not take logical layout into account<br>
	 * Original signature : <code>bool JNACorsairSetLedsColors(int, JNACorsairLedColor*)</code><br>
	 * <i>native declaration : include\CorsairCUEJNAWrapper.h:4</i>
	 */
	public static boolean JNACorsairSetLedsColors(int size, Pointer<JNACorsairLedColor> ledsColors) {
		return JNACorsairSetLedsColors(size, Pointer.getPeer(ledsColors));
	}
	protected native static boolean JNACorsairSetLedsColors(int size, @Ptr long ledsColors);
	/**
	 * Original signature : <code>bool JNACorsairSetLedsColorsAsync(int, JNACorsairLedColor*, JNACorsairSetLedsColorsAsync_CallbackType_callback*, void*)</code><br>
	 * <i>native declaration : include\CorsairCUEJNAWrapper.h:6</i>
	 */
	public static boolean JNACorsairSetLedsColorsAsync(int size, Pointer<JNACorsairLedColor> ledsColors, Pointer<CorsairCUEJNAWrapperLibrary.JNACorsairSetLedsColorsAsync_CallbackType_callback > CallbackType, Pointer<? > context) {
		return JNACorsairSetLedsColorsAsync(size, Pointer.getPeer(ledsColors), Pointer.getPeer(CallbackType), Pointer.getPeer(context));
	}
	protected native static boolean JNACorsairSetLedsColorsAsync(int size, @Ptr long ledsColors, @Ptr long CallbackType, @Ptr long context);
	/**
	 * returns number of connected Corsair devices that support lighting control.<br>
	 * Original signature : <code>int JNACorsairGetDeviceCount()</code><br>
	 * <i>native declaration : include\CorsairCUEJNAWrapper.h:9</i>
	 */
	public static native int JNACorsairGetDeviceCount();
	/**
	 * returns information about device at provided index<br>
	 * Original signature : <code>JNACorsairDeviceInfo* JNACorsairGetDeviceInfo(int)</code><br>
	 * <i>native declaration : include\CorsairCUEJNAWrapper.h:12</i>
	 */
	public static Pointer<JNACorsairDeviceInfo> JNACorsairGetDeviceInfo(int deviceIndex) {
		return (Pointer)Pointer.pointerToAddress(JNACorsairGetDeviceInfo$2(deviceIndex), JNACorsairDeviceInfo.class);
	}
	@Ptr
	@Name("JNACorsairGetDeviceInfo")
	protected native static long JNACorsairGetDeviceInfo$2(int deviceIndex);
	/**
	 * provides list of keyboard LEDs with their physical positions.<br>
	 * Original signature : <code>JNACorsairLedPositions* JNACorsairGetLedPositions()</code><br>
	 * <i>native declaration : include\CorsairCUEJNAWrapper.h:15</i>
	 */
	public static Pointer<JNACorsairLedPositions> JNACorsairGetLedPositions() {
		return (Pointer)Pointer.pointerToAddress(JNACorsairGetLedPositions$2(), JNACorsairLedPositions.class);
	}
	@Ptr
	@Name("JNACorsairGetLedPositions")
	protected native static long JNACorsairGetLedPositions$2();
	/**
	 * provides list of keyboard or mousemat LEDs with their physical positions.<br>
	 * Original signature : <code>JNACorsairLedPositions* JNACorsairGetLedPositionsByDeviceIndex(int)</code><br>
	 * <i>native declaration : include\CorsairCUEJNAWrapper.h:18</i>
	 */
	public static Pointer<JNACorsairLedPositions> JNACorsairGetLedPositionsByDeviceIndex(int deviceIndex) {
		return (Pointer)Pointer.pointerToAddress(JNACorsairGetLedPositionsByDeviceIndex$2(deviceIndex), JNACorsairLedPositions.class);
	}
	@Ptr
	@Name("JNACorsairGetLedPositionsByDeviceIndex")
	protected native static long JNACorsairGetLedPositionsByDeviceIndex$2(int deviceIndex);
	/**
	 * retrieves led id for key name taking logical layout into account.<br>
	 * Original signature : <code>CorsairLedId JNACorsairGetLedIdForKeyName(char)</code><br>
	 * <i>native declaration : include\CorsairCUEJNAWrapper.h:21</i>
	 */
	public static IntValuedEnum<CorsairCUEJNAWrapperLibrary.CorsairLedId > JNACorsairGetLedIdForKeyName(byte keyName) {
		return FlagSet.fromValue(JNACorsairGetLedIdForKeyName$2(keyName), CorsairCUEJNAWrapperLibrary.CorsairLedId.class);
	}
	@Name("JNACorsairGetLedIdForKeyName")
	protected native static int JNACorsairGetLedIdForKeyName$2(byte keyName);
	/**
	 * requestes control using specified access mode. By default client has shared control over lighting so there is no need to call CorsairRequestControl unless client requires exclusive control<br>
	 * Original signature : <code>bool JNACorsairRequestControl(CorsairAccessMode)</code><br>
	 * <i>native declaration : include\CorsairCUEJNAWrapper.h:24</i>
	 */
	public static boolean JNACorsairRequestControl(IntValuedEnum<CorsairCUEJNAWrapperLibrary.CorsairAccessMode > accessMode) {
		return JNACorsairRequestControl((int)accessMode.value());
	}
	protected native static boolean JNACorsairRequestControl(int accessMode);
	/**
	 * checks file and protocol version of CUE to understand which of SDK functions can be used with this version of CUE<br>
	 * Original signature : <code>JNACorsairProtocolDetails* JNACorsairPerformProtocolHandshake()</code><br>
	 * <i>native declaration : include\CorsairCUEJNAWrapper.h:27</i>
	 */
	public static Pointer<JNACorsairProtocolDetails> JNACorsairPerformProtocolHandshake() {
		return (Pointer)Pointer.pointerToAddress(JNACorsairPerformProtocolHandshake$2(), JNACorsairProtocolDetails.class);
	}
	@Ptr
	@Name("JNACorsairPerformProtocolHandshake")
	protected native static long JNACorsairPerformProtocolHandshake$2();
	/**
	 * returns last error that occured while using any of Corsair* functions<br>
	 * Original signature : <code>CorsairError JNACorsairGetLastError()</code><br>
	 * <i>native declaration : include\CorsairCUEJNAWrapper.h:30</i>
	 */
	public static IntValuedEnum<CorsairCUEJNAWrapperLibrary.CorsairError > JNACorsairGetLastError() {
		return FlagSet.fromValue(JNACorsairGetLastError$2(), CorsairCUEJNAWrapperLibrary.CorsairError.class);
	}
	@Name("JNACorsairGetLastError")
	protected native static int JNACorsairGetLastError$2();
	/**
	 * releases previously requested control for specified access mode<br>
	 * Original signature : <code>bool JNACorsairReleaseControl(CorsairAccessMode)</code><br>
	 * <i>native declaration : include\CorsairCUEJNAWrapper.h:33</i>
	 */
	public static boolean JNACorsairReleaseControl(IntValuedEnum<CorsairCUEJNAWrapperLibrary.CorsairAccessMode > accessMode) {
		return JNACorsairReleaseControl((int)accessMode.value());
	}
	protected native static boolean JNACorsairReleaseControl(int accessMode);
}
